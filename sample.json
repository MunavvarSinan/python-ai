{"contexts": [{"text": ": Process Control  \n \n\uf0fc Changing User IDs and Group IDs  \n\uf0fc Interpreter Files  \n\uf0fc System Function  \n\uf0fc Process Accounting  \n\uf0fc User Identification  \n\uf0fc Process Times  \n\uf0fc I/O Redirection  \n \nCHANGING USER IDs AND  GROUP IDs  \n\uf0fc When our programs need additional privileges or need to gain access to resources that they currently \naren't allowed to access, they need to change their user or group ID to an ID that has the appropriate \nprivilege or access.  \n\uf0fc Similarly, when our  programs need to lower their privileges or prevent access to certain resources, they \ndo so by changing either their user ID or group ID to an ID without the privilege or ability access to the \nresource.  \n#include <unistd.h>  \n \nint setuid(uid_t uid);  \nint setg id(gid_t gid);  \n \n \n             Both return: 0 if OK, 1 on error  \nThere are rules for who can change the IDs. Let's consider only the user ID for now. (Everything we describe for \nthe user ID also applies to the group ID.)  \nIf the process has superuser  privileges, the setuid function sets the real user ID, effective user ID, and \nsaved set -user -ID to uid.  \nIf the process does not have superuser privileges, but uid equals either the real user ID or the saved set -\nuser - ID, setuid sets only the effective u ser ID to uid. The real user ID and the saved set -user -ID are not \nchanged. If neither of these two conditions is true, errno  is set to EPERM, and 1 is returned.  \n \nWe can make a few statements about the three user IDs that the kernel maintains.  \n\uf0fc Only a superu ser process can change the real user ID. Normally, the real user ID is set by the login(1) \nprogram when we log in and never changes. Because login is a superuser process, it sets all three user IDs \nwhen it calls  setuid.  \n\uf0fc The effective user ID is set by the exec functions only if the set -user -ID bit is set for the program file. If the \nset-user -ID bit is not set, the exec functions leave the effective user ID as its current value. We can call \nsetuid at any time to set the effective user ID to either the real u ser ID or the saved set -user -ID. Naturally, \nwe can't set the effective user ID to any random  value.  \n\uf0fc The saved set -user -ID is copied from the effective user ID by exec. If the file's set -user -ID bit is set, this \ncopy is saved after exec  stores the effective  user ID from the file's user ID.  \n \n \n \n \n \nModule 4  UNIX PROGRAMMING  \n \n \n2BrCE, Bengaluru  \n setreuid  and setregid  Functions  \n \n\uf0fc Swapping of the real user ID and the effective user ID with the setreuid function.  \n \n \n \nBoth return : 0 if OK, -1 on error  \n\uf0fc We can supply a value of 1 for any of the arguments to indicate that the corresponding ID should remain \nunchanged.  \n\uf0fc The rule is simple: an unprivileged user can always swap between the real user ID and the effective user \nID.  \n\uf0fc This allows a set -user -ID program to swap to the user\u2019s normal permissions and swap back again later for \nset-user - ID operations.  \n \nseteuid and setegid functions :  \n\uf0fc POSIX.1 includes the two functions seteuid and setegid. These functions are similar to setuid and setgid, \nbut only the effective user ID or effective group ID is changed.  \n \nBoth return : 0 if OK, 1 on error  \n\uf0fc An unprivileged user can set its effective user ID to either its real user ID or its saved set -user -ID. \n\uf0fc For a privileged user, only the effective user ID is set to uid. (This differs from the setuid function, whi ch \nchanges all three user  IDs.)  \n \nFigure: Summary of all the functions that set the various user Ids  \n #include <unistd.h>  \nint setreuid(uid_t ruid, uid_t euid);  \nint setregid(gid_t rgid, gid_t egid);  \n#include  <unistd.h>  \nint seteuid(uid_t  uid);  \nint setegid(gid _t gid); \nModule 4  UNIX PROGRAMMING  \n \n \n3BrCE, Bengaluru  \n INTERPRETER FILES  \n\uf0fc These files are text files that begin with a line of the form  \n  #! pathname [ optional -argument ]  \n\uf0fc The space between the exclamation point and the pathname is optional. The most common of these \ninterpreter files begin with the line  \n         #!/bin/sh  \n\uf0fc The pathname is normally an absolute pathname, since no special operations are performed on it (i.e., \nPATH is not used).  \n\uf0fc The recognition of these files is done within the kernel as part of processing the exec system call.  \n\uf0fc The actual file that gets executed by the kernel is not the interpreter file, but the file specified by the \npathname on the first line of the interpreter file.  \n\uf0fc Be sure to differentiate between the interpreter filea text file that begins with #!and the interpreter, \nwhich is specified by the pathname on the first line of the interpreter file.  \n\uf0fc Be aware that systems place a size limit on the first line of an interpre ter file. This limit includes the #!, the \npathname, the optional argument, the terminating newline, and any spaces.  \n \nA program that exec s an interpreter file  \n#include \"apue.h\" \n#include<sys/wait.h>  \nint main(void)  \n{ \npid_t pid; \nif ((pid = fork()) < 0) { \nerr_sys(\"fork error\");  \n} else if (pid ==  0) { /* child */  \n   if (execl(\"/home/sar/bin/testinterp\",\"testinterp\", \"myarg1\", \"MY ARG2\" , (char *)0) < 0) \nerr_sys(\"execl error\");  \n} \nif (waitpid(pid, NULL, 0) < 0) /* parent \n*/ err_sys(\"waitpid error\");  \nexit(0);  \n} \nOutput: \n$ cat \n/home/sar/bin/testinterp \n#!/home/sar/bin/echoarg foo  \n$ ./a.out  \nargv[0]: \n/home/sar/bin/echoarg \nargv[1]: foo  \nargv[2]: \n/home/sar/bin/testinterp \nargv[3]: myarg1  \nargv[4]: MY  ARG2 \n \nsystem       FUNCTION  \n#include <stdlib.h>  \nint system(const char * cmdstring);  \n                                      \n \nModule 4  UNIX PROGRAMMING  \n \n \n4BrCE, Bengaluru  \n \uf0fc If  cmdstring  is  a  null  pointer,  system returns  nonzero  only  if  a  command  processor  is  available.  This  \nfeature  determines  whether  the  system function  is  supported  on  a  given  operati ng  system.   \n\uf0fc Under  the  UNIX  System,  system   is always available.  \nBecause system   is implemented by calling fork, exec, and waitpid, there are three types of return values.  \n1. If either  the fork fails or waitpid                     returns  an error  other  than  EINTR,  system  returns  1 with  errno  set to \nindicate the  error.  \n2. If the exec  fails,  implying  that the shell  can't  be executed,  the return  value  is as if the shell  had executed  \nexit(127).  \n3. Otherwise, all three functions fork, exec, and waitpid  succeed, and the return value from system is the \ntermination status of the shell, in the format specified for  waitpid.  \n \nProgram: The system  function, without signal handling  \n \n#include<sys/wait.h> \n#include<errno.h> \n#include<unistd.h>  \nint system(const  char *cmdstring)  /* version without signal handling  */ \n{ \nif (cmdstring == NULL)  \nreturn(1);  /* always a command processor with UNIX  */ \n \nif ((pid = fork()) < 0)  \n{ \nstatus = -1; /* probably out of processes  */ \n}  \nelse if (pid ==  0) \n { execl(\"/bin/sh\", \"sh\", \" -c\", cmdstring, (char  *)0); \n_exit(127);  /* execl error  */ \n }  \nelse { /* parent  */ \nwhile (waitpid(pid, &status, 0) < 0)  \n{ if (errno != EINTR) {  \nstatus = -1;  \n} \n} \n} \nreturn(status);  \n} \n \nProgram: Calling the system function  \n#include \"apue.h\" \n#include <sys/wait.h>  \nint main(void)  \n{ \nint status; \nif ((status = system(\"date\")) < 0) \nerr_sys(\"system() error\");  \npr_exit(status);  \n \nif ((status = system(\"nosuchcommand\")) < 0) \nerr_sys(\"system() error\");  \nModule 4  UNIX PROGRAMMING  \n \n \n5BrCE, Bengaluru  \n pr_exit(status);  \n \nif ((status = system(\"who; exit 44\")) < 0) \nerr_sys(\"system() error\");  \npr_exit(status);  \n \nexit(0);  \n} \n \nProgram: Execute the command -line argument using system \n#include \"apue.h\"  \n \nint main(int argc, char *argv[])  \n{ \nint status; \n \nif (argc < 2)  \nerr_quit(\"command -line argument required\");  \n \nif ((status = system( argv[1])) < 0) \nerr_sys(\"system() error\");  \npr_exit(status);  \n \nexit(0);  \n} \n \nProgram: Print real and effective user IDs  \n#include \"apue.h\"  \n \nint main(void)  \n{ \nprintf(\"real uid = %d, effective uid = %d \\n\", getuid(), geteuid());  \nexit(0);  \n} \nPROCESS ACCOUNTING  \n\uf0fc Most UNIX systems provide an option to do process accounting. When enabled, the kernel writes an \naccounting record each time a process  terminates. \uf020\n\uf0fc These accounting records are typically a small amount of binary data with the name of the command, the \namount of C PU time used, the user ID and group ID, the starting time, and so  on.\uf020\n\uf0fc A superuser executes accton with a pathname argument to enable  accounting. \uf020\n\uf0fc The accounting records are written to the specified file, which is usually /var/account/acct. Accounting is \nturned off by executing accton without any  arguments. \uf020\n\uf0fc The data required for the accounting record, such as CPU times and number of characters transferred, is \nkept by the kernel in the process table and initialized whenever a new process is created, as in the child \nafter a fork .\uf020\n\uf0fc Each accounting record is written when the process  terminates. \uf020\n\uf0fc This means that the order of the records in the accounting file corresponds to the termination order of \nthe processes, not the order in which they were  started.\uf020\n\uf0fc The accounting records correspond to processes, not  programs. \uf020\n\uf0fc A new record is initialized by the kernel for the child after a fork , not when a new program is        \n executed. The structure of the accounting records is defined in the header <sys/acct.h>  and lo oks      \nModule 4  UNIX PROGRAMMING  \n \n \n6BrCE, Bengaluru  \n  something like \uf020\ntypedef u_short comp_t; /* 3-bit base 8 exponent; 13 -bit fraction  */ \nstruct acct  \n{  \nchar ac_flag;  /* flag */ \nchar ac_stat;  /* termination status (signal & core flag only) */  \n  /* (Solaris only) */  \nuid_t ac_uid; /* real user ID */ \ngid_t ac_gid; /* real group ID */  \ndev_t ac_tty; /* controlling terminal */  \ntime_t ac_btime;  /* starting calendar time */  \ncomp_t ac_utime;  /* user CPU time (clock ticks) */  \ncomp_t ac_stime;  /* system CPU time (clock ticks) */  \ncomp_t ac_etime;  /* elapsed time (clock ticks) */  \ncomp_t ac_mem; /* average memory usage */  \ncomp_t ac_io; /* bytes transferred (by read and write) */  \n  /* \"blocks\" on BSD systems */  \ncomp_t ac_rw; /* blocks read or written */  \n  /* (not present on BSD systems) */  \nchar ac_comm[8];  /* command name: [8] for Solaris, */  \n  /* [10] for Mac OS X, [16] for FreeBSD, and */  \n  /* [17] for Linux */  \n};    \nThe ac_flag member records certain events during the execution of the process.   \nac_flag Description  \nAFORK process is the result of fork , but never called exec \nASU process used superuser privileges  \nACOMPAT process used compatibility mode  \nACORE process dumped core   \nAXSIG process was killed by a signal  \nAEXPND expanded accounting entry   \n \n \n \nProcess structure  for accounting example  \n \nModule 4  UNIX PROGRAMMING  \n \n \n7BrCE, Bengaluru  \n USER IDENTIFICATION  \n\uf0fc Any process can find out its real and effective user ID and group ID.  \n\uf0fc Sometimes, however, we want to find out the login name of the user who's running the program.  \n\uf0fc We could call getpwuid(getuid()) , but what if a single user has multiple login names, each with the same \nuser ID? (A person might have multiple entries in the password file with the same user ID to have a \ndiffe rent login shell for each entry ). \n\uf0fc The system normally keeps track of the name we log in and the getlogin   function provides a way to fetch \nthat login name.  \n#include <unistd.h>  \nchar *getlogin(void);  \n           Returns : pointer to string giving login name if OK, NULL on error  \n \n\uf0fc This function can fail if the process is not attached to a terminal that a user logged in to.  \n \nPROCESS TIMES  \n \n\uf0fc We describe three times that we can measure: wall clock time, user CPU time, and system CPU time. Any \nprocess can call the times function to obtain these values for itself and any terminated children.  \n#include<sys/ times.h>  \nClock_t times(struct tms * buf)  \nReturns: elapsed wall clock time in clock ticks if OK, 1 on error  \n \n\uf0fc This function fills in the tms structure pointed to by buf:  \nstruct tms  \n{ \nclock_t  tms_utime;  /* user CPU  time */  \nclock_t  tms_stime;                  /* system CPU time */  \nclock_t  tms_cutime;   /* user CPU time,  terminated children */  \nclock_t tms_cstime;                              /* system CPU time, terminated children */  \n}; \n \n\uf0fc Note that the structure does not contain any measurement for the wall clock time.  \n\uf0fc Instead, the function returns the wall clock time as the value of the function, each time it's called.  \n\uf0fc This value is measured from some arbitrary point in the past, so we can't use its absolute value; instead, \nwe use its relative  value.  \n \nI/O Redirection  \n \n\uf0fc It scans the command line for the occurrence of the special redirection characters <,>,or >>  \n\uf0fc Unix provides the capability to change where standard input comes from or where ouput goes \nusing a concept called Input/Output(I/O) redirection.  \n\uf0fc I/O redirection is accomplished using a redirection operator which allows the user to speci fy the \ninput or outp ut data be directed to a file.  \n\uf0fc The output redirection operator is the >(greater than) symbol and general syntax:  \ncommand > output_file_spec  \nModule 4  UNIX PROGRAMMING  \n \n \n8BrCE, Bengaluru  \n \uf0fc Spaces around the redirection is not mandatory, but to add readability to the command.  \n \nEg: $ls > my_files  [Enter]  \n         $ cat my_files [Enter]  \n      foo \n      bar  \n      fred  \n      dino  \n                $ $ echo \u201cHello World!\u201d > my_files [Enter]  \n$ cat my _files [Enter]  \nHello World!   \n \n\uf0fc The append operator is the >>  \n$ ls > my_files [Enter]  \n$ echo \u201cHello World!\u201d >>  my_files [Enter]  \n   $ cat my_files [Enter]  \n      foo \n      bar  \n      fred  \n      dino  \n      Hello World!  \n \n\uf0fc The first output redirection creates the file if it does not exist or overwrites its content if it does and the \nsecond redirection appends the string \u201cHello World!\u201d to the end of the file.  \n\uf0fc When using the append redirection operator, if the file does not exist, >> will cause its creation and \nappend the output (to the empty file).  \n\uf0fc The ability also exists to redirect the standard input using the inp ut redirection operator, the < (less than) \nsymbol  \n\uf0fc The general syntax of input redirection:  \ncommand < input_file_spec   \n \n \nMODULE 4  UNIX Programming  \n \n \n1BrCE, Bengaluru  \n "}, {"text": " : INTERPROCESS COMMUNICATION  \nOverview of IPC Methods  \n\uf0fc Pipes  \n\uf0fc Popen and pclose Functions  \n\uf0fc Coprocesses  \n\uf0fc FIFOs  \n\uf0fc System V IPC  \n\uf0fc Message Queues  \n\uf0fc Semaphores  \n \nINTRODUCTION  \n\uf0fc IPC enables one application to control another application, and for several applications  to share the same \ndata without interfering with one another. IPC is required in all multiprocessing systems, but it is not \ngenerally supported by single -process operating systems.  \n\uf0fc The various forms of IPC that are supported on a UNIX system are as follows  : \n1) Half duplex  Pipes  \n2) FIFO\u2019s  \n3) Full duplex  Pipes  \n4) Named full duplex  Pipes  \n5) Message  queues  \n6) Shared  memory  \n7) Semaphores  \n8) Sockets  \n9) STREAMS  \n \n\uf0fc The first seven forms of IPC are usually restricted to IPC between processes on the same host.  \n\uf0fc The final two i.e. Sockets and STREAMS are the only two that are generally supported for IPC between \nprocesses on different hosts.  \n \nPIPES  \n \n\uf0fc Pipes are the oldest form of UNIX System IPC. Pipes have two limitations.  \n\uf0fc Historically, they have been half duplex (i.e., data flows in only one direction).  \n\uf0fc Pipes can be used only between processes that have a common ancestor.  \n\uf0fc Normally, a pipe is created by a process, that process calls fork, and the pipe is used between the parent \nand the child.  \n\uf0fc A pipe is created by calling the pipe  function.  \n \n#include <unistd.h>  \nint pipe(int filedes[2]);  \n                                           Returns: 0 if OK, 1 on error.  \n \n\uf0fc Two file descriptors are returned through the filedes argument: filedes[0] is open for reading, and \nfiledes[1] is open for writing.  \n\uf0fc The output of filedes[1] is the input for filedes[0].  \nMODULE 4  UNIX Programming  \n \n \n2BrCE, Bengaluru  \n \uf0fc Two ways to picture a half -duplex pipe are shown in Figure  1.  \n\uf0fc The left half of the figure shows the two ends of the pipe connected in a single process. The right half of \nthe figure emphasizes that the data in the pipe flows through the kernel.  \n \n \nFigure 1. Two ways to view a half -duplex pipe  \n\uf0fc A pipe in a single process is next to useless.  \n\uf0fc Normally, the process that calls pipe then calls fork, creating an IPC channel from the parent to the child or \nvice versa. Figure 2 shows this scenario.  \nFigure 2 Half -duplex pipe after a fork \n \n\uf0fc What happens after the fork depends on which direction of data flow we want.  \n\uf0fc For a pipe from the parent to the child, the parent closes the read end of the pipe (fd[0]), and the  child \ncloses the write end (fd[1]). Figure 3 shows the resulting arrangement of descriptors.  \nFigure 3 Pipe from parent to child  \nMODULE 4  UNIX Programming  \n \n \n3BrCE, Bengaluru  \n \uf0fc For a pipe from the child to the parent, the parent closes fd[1], and the child closes fd[0]. When one end of \na pipe is closed , the following two rules apply.  \n\uf0d8 If we read from a pipe whose write end has been closed, read returns 0 to indicate an end of file \nafter all the data has been  read.  \n\uf0d8 If we write to a pipe whose read end has been closed, the signal SIGPIPE  is generated. If w e either \nignore the  signal  or catch  it and  return  from the  signal  handler,  write  returns  1 with errno  set to \nEPIPE.  \nPROGRAM: shows the code to create a pipe between a parent and its child and to send data down the pipe.  \n#include \"apue.h\"  \nint main(void)  \n{ \nint n; \nint fd[2]; \npid_t pid; \nchar line[MAXLINE];  \n \nif (pipe(fd) < 0) \nerr_sys(\"pipe  \nerror\");  \nif ((pid = fork()) < 0) { \nerr_sys(\"fork  error\");  \n} else if (pid >  0) { /* \nparent */ close(fd[0]);  \nwrite(fd[1], \"hello world \\n\", 12);  \n} else { /* \nchild */ close(fd[1] ); \nn = read(fd[0], line, \nMAXLINE); \nwrite(STDOUT_FILENO, line, \nn); \n} \nexit(0);  \n} \n \npopen           AND  pclose  FUNCTIONS  \n\uf0fc Since a common operation is to create a pipe to another process, to either read its output or send it \ninput, the standard I/O library has historically provided the popen and pclose functions.  \n\uf0fc These two functions handle all the dirty work that we've been d oing ourselves: creating a pipe, forking a \nchild, closing the unused ends of the pipe, executing a shell to run the command, and waiting for the \ncommand to terminate.  \n#include <stdio.h>  \nFILE *popen(const char *cmdstring, const char *type);  \n                                                                   Returns: file pointer if OK, NULL on error \n \nMODULE 4  UNIX Programming  \n \n \n4BrCE, Bengaluru  \n int pclose(FILE *fp);  \n \n                                  Returns: termination status of cmdstring, or 1 on error  \n \n\uf0fc The function popen does a fork and exec to execute the cmdstring, and returns a standard I/O \nfile pointer.  \nIf type is \"r\", the file pointer is connected to the standard output of cmdstring  \nFigure 4  Result of fp = popen (cmdstring, \"r\") \n \nIf type is \"w\", the file pointer is connected to the standard input of cmdstring, as shown:  \n \nFigure 5  Result of fp = popen (cmdstring, \"w\") \n \n \nCOPROCESSES  \n \n\uf0fc A UNIX system filter is a program that reads from standard input and writes to standard output.  \n\uf0fc Filters are normal ly connected linearly in shell pipelines.  \n\uf0fc A filter becomes a coprocess when the same program generates the filter's input and reads the filter's \noutput.  \n\uf0fc A coprocess normally runs in the background from a shell, and its standard input and standard output \nare connected to another program using a  pipe.  \n\uf0fc The process creates two pipes: one is the standard input of the coprocess, and the other is the standard \noutput of the coprocess. Figure 6 shows this  arrangement.  \n                       Figure 6. Driving a coprocess by writing its standard input and reading its standard output  \n \nProgram: Simple filter to add two numbers  \n#include \"apue.h\"  \nint main(void)  \n{ \nint n, int1, int2; \nchar line[MAXLINE];  \nMODULE 4  UNIX Programming  \n \n \n5BrCE, Bengaluru  \n  \nwhile ((n = read(STDIN_FILENO, line, MAXLINE)) > 0)  \n{    line[n]  = 0; /* null terminate  */ \nif (sscanf(line, \"%d%d\", &int1, &int2) == 2)  \n{ sprintf(line, \"%d \\n\", int1 + int2);  \nn = strlen(line);  \nif (write(STDOUT_FILENO, line, n) != n)  \n     err_sys(\"write error\");  \n} else {  \nif (write(STDOUT_FILENO, \"invalid args \\n\", 13) != 13) \nerr_sys(\"write error\");  \n} \n} \nexit(0);  \n} \n \nFIFOs  \n\uf0fc FIFOs are sometimes called named pipes. Pipes can be used only between related processes when a \ncommon ancestor has created the pipe.  \n \n#include <sys/stat.h>  \nint mkfifo(const char *pathname, mode_t mode);  \nReturns: 0 if OK, -1 on error  \nOnce we have used mkfifo to create a FIFO, we open it using open . When we open a FIFO, the \nnonblocking flag ( O_NONBLOCK ) affects what happens.  \nIn the normal case ( O_NONBLOCK not specified), an open for read -only blocks until some other \nprocess opens the FIFO for writing. Similarly, an open for write -only blocks until some other \nprocess opens the FIFO for reading.  \nIf O_NONBLOCK  is specified, an open for read -only returns immediately. But an open for write -only \nreturns 1 with errno set to ENXIO if no process has the FIFO open for reading.  \n \nThere are two uses for FIFOs.  \n\uf0fc FIFOs are used by shell commands to pass data from one shell pipeline to another without creating \nintermediate temporary  files.  \n\uf0fc FIFOs are used as rendezvous points in client -server applications to pass data between the clients and \nthe servers.  \n \nExample Using FIFOs to Duplicate Output Streams  \n\uf0fc FIFOs can be used to duplicate an output stream in a series of shell commands.  \n\uf0fc This prevents wr iting the data to an intermediate disk file. Consider a procedure that needs to \nprocess a filtered input stream twice. Figure shows this arrangement.  \nMODULE 4  UNIX Programming  \n \n \n6BrCE, Bengaluru  \n FIGURE : Procedure that processes a filtered input stream twice  \n\uf0fc With a FIFO and the UNIX program tee(1), w e can accomplish this procedure without using a \ntemporary file. (The tee program copies its standard input to both its standard output and to the file \nnamed on its command line.)  \n \nmkfifo \nfifo1 prog3 \n< fifo1 &  \nprog1 < infile | tee fifo1 | prog2  \n \n\uf0fc We create t he FIFO and then start prog3 in the background, reading from the FIFO. We then start \nprog1 and use tee to send its input to both the FIFO and prog2 . Figure shows the process \narrangement.  \n                                                               \n \n FIGURE : Using a FIFO and tee to send a stream to two different processes  \nExample Client -Server Communication Using a FIFO  \n\uf0b7 FIFO\u2019s  can be used  to send  data  between  a client  and a server.  If we have  a server  that is contacted  by \nnumerous clients, each client  can write its request to a well -known FIFO that the server creates. Since \nthere are multiple writers for the FIFO, the requests sent by the clients to the server need to be less \nthan PIPE_BUF bytes in  size.  \n\uf0b7 This prevents any interleaving of the client writes. The problem in using FIFOs for this type of client \nserver communication is how to send replies back from the server to each  client.  \n\uf0b7 A single  FIFO  can\u2019t  be used,  as the clients  would  never  know  when  to read  their  response  versus  responses for \nother clients. One solution is for each client to send its process ID with the request. The server then \ncreates  a unique  FIFO  for each  client,  using  a pathname  based  on the client\u2019sprocess  ID. \n\uf0b7 For example, the server can create a FIFO with the name /vtu/ ser.XXXXX, where XXXXX is replaced with \nthe client\u2019s process ID. This arrangement works, although it is impossible for the server to tell whether a \nclient crashes. This causes the client -specific FIFOs to be left in the file  system.  \n\uf0b7  The server  also must  catch  SIGPIPE,  since  it\u2019s possible  for a client  to send  a request  and terminate  before \nreading the response, leaving the client -specific FIFO with one writer (the server) and no  reader.  \nMODULE 4  UNIX Programming  \n \n \n7BrCE, Bengaluru  \n Figure : Clients sending requests to a server using a FIFO  \n \nFigure: Client -server communication using FIFOs  \n \nSystem V IPC  \n \n\uf076 Identifiers and  Keys\uf020\nEach IPC structure (message queue, semaphore, or shared memory segment) in the kernel is referred to by a \nnon- negative integer identifier. The identifier is an internal name for a n IPC object. Cooperating processes need \nan external naming scheme to be able to rendezvous using the same IPC object. For this purpose, an IPC object \nis associated with a key that acts as an external name.  \nWhenever an IPC structure is being created, a key  must be specified. The data type of this key is the primitive \nsystem data type key_t, which is often defined as a long integer in the header <sys/types.h>. This key is \nconverted into an identifier by the kernel.  \nThere are various ways for a client and a server to rendezvous at the same IPC structure.  \n\uf0fc The server can create a new IPC structure by specifying a key of IPC_PRIVATE and store the returned \nMODULE 4  UNIX Programming  \n \n \n8BrCE, Bengaluru  \n identifier somewhere (such as a file) for the client to obtain. The key IPC_PRIVATE guarantees that the \nserv er creates a new IPC structure. The disadvantage to this technique is that file system operations are \nrequired for the server to write the integer identifier to a file, and then for the clients to retrieve this \nidentifier later.  \nThe IPC_PRIVATE key is also  used in a parent -child relationship. The parent creates a new IPC structure \nspecifying IPC_PRIVATE, and the resulting identifier is then available to the child after the fork. The child \ncan pass the identifier to a new program as an argument to one of the  exec  functions.  \n\uf0fc The client and the server can agree on a key by defining the key in a common header, for example. The \nserver then creates a new IPC structure specifying this key. The problem with this approach is that it's \npossible for the key to already be associated with an IPC structure, in which case the get function \n(msgget, semget, or shmget) returns an error. The server must handle this error, deleting the existing \nIPC structure, and try to create it  again.  \n\uf0fc The client and the server can agree on a p athname and project ID (the project ID is a character value \nbetween 0 and 255) and call the function ftok to convert these two values into a key. This key is then \nused in step 2. The only service provided by ftok  is a way of generating a key from a pathname and \nproject ID.  \n \n#include <sys/ipc.h>  \nkey_t ftok(const char *path, int id);  \nReturns: key if OK, (key_t) -1 on error  \n \n\uf0fc The path argument must refer to an existing file. Only the lower 8 bits of id are used when generating the \nkey. \n\uf0fc The key created by ftok is usually formed by taking parts of the st_dev and st_ino fields in the stat \nstructure corresponding to the given pathname and combining them with the project ID.  \n\uf0fc If two pathnames refer to two different files, then ftok usually re turns two different keys for the two \npathnames. However, because both i -node numbers and keys are often stored in long integers, there \ncan be information loss creating a key. This means that two different pathnames to different files can \ngenerate the same key if the same project ID is  used.  \n \n\uf076 Permission  Structure \uf020\n\uf0fc XSI IPC associates an ipc_perm structure with each IPC structure. This structure defines the permissions \nand owner and includes at least the following members:  \nstruct ipc_perm  \n{ \nuid_t uid; /* owner's effective user id */  \ngid_t gid; /* owner's effective group id */  \nuid_t cuid; /* creator's effective user id */  \ngid_t cgid; /* creator's effective group id */  \nmode_t mode; /* access modes  */ \n. \n. \n         }; \n\uf0fc All the fields are initialized when the IPC structure is created. At a later time, we can modify the uid, gid, \nand mode fields by calling msgctl, semctl, or shmctl. To change these values, the calling process must be \nMODULE 4  UNIX Programming  \n \n \n9BrCE, Bengaluru  \n either the creator of the IPC structure  or the superuser. Changing these fields is similar to calling chown  \nor chmod          for a file.  \nPermission  Bit \nuser-read  0400 \nuser-write (alter)  0200 \ngroup -read  0040 \ngroup -write (alter)  0020 \nother -read  0004 \nother -write (alter)  0002 \nXSI IPC permissions  \n\uf076 Advantages and  Disadvantages \uf020\n\uf0fc A fundamental problem with XSI IPC( System V IPC ) is that the IPC structures are system wide and do \nnot have a reference count. For example, if we create a message queue, place some messages on the \nqueue, and then terminate, the message queue and its contents are not deleted. They remain in the \nsystem until specifically read or deleted by some process calling msgrcv or msgctl , by someone \nexecuting the ipcrm (1) command, or by the system being rebooted. Compare this w ith a pipe, which is \ncompletely removed when the last process to reference it terminates. With a FIFO, although the name \nstays in the file system until explicitly removed, any data left in a FIFO is removed when the last process \nto reference the FIFO  termi nates.\uf020\n\uf0fc Another problem with XSI IPC ( System V IPC ) is that these IPC structures are not known by names in \nthe file system. We can't access them and modify their properties with the functions. Almost a dozen \nnew system calls ( msgget , semop , shmat , and so on) were added to the kernel to support these IPC \nobjects. We can't see the IPC objects with an ls command, we can't remove them with the rm \ncommand, and we can't change their permissions with the chmod command. Instead, two new \ncommands ipcs (1) and ipcrm (1)were added. \uf020\n\uf0fc Since these forms of IPC don't use file descriptors, we can't use the multiplexed I/O functions ( select \nand poll ) with them. This makes it harder to use more than one of these IPC structures at a time or to \nuse any of these IPC structures wit h file or device I/O. For example, we can't have a server wait for a \nmessage to be placed on one of two message queues without some form of busy wait  loop.\uf020\n \n \nMESSAGE QUEUES  \n\uf0fc A message queue is a linked list of messages stored within the kernel and identified by a message queue \nidentifier. We'll call the message queue just a queue and its identifier a queue ID.  \n\uf0fc A new queue is created or an existing queue opened by msgget.  \n\uf0fc New messages are added to the end of a queue by msgsnd.  \n\uf0fc Every message has a p ositive long integer type field, a non -negative length, and the actual data bytes \n(corresponding to the length), all of which are specified to msgsnd  when the message is added to a \nqueue.  \n\uf0fc Messages are fetched from a queue by msgrcv. We don't have to fetch  the messages in a first -in, first -\nout order. Instead, we can fetch messages based on their type field.  \nEach queue has the following msqid_ds  structure associated with it:  \n \nMODULE 4  UNIX Programming  \n \n \n10BrCE, Bengaluru  \n struct msqid_ds  \n{ \nStruct ipc_perm    msg_perm;  \nmsgqnum_t    msg_qnum;                        /* # of messages on queue */  \nmsglen_t     msg_qbytes;           /* max # of bytes on queue */  \npid_t             msg_lspid;                            /* pid of last msgsnd() */  \npid_t             msg_lspid;                           /* pid of last msgrc v() */  \ntime_t  msg_stime;                        /* last-msgsnd() time */  \ntime_t  msg_rtime;           /* last-msgrcv() time */  \ntime_t  msg_ctime;                        /* last-change time  */ \n. \n. \n}; \nThis structure defines the current status of the queue.  \nmsgget  \n\uf0fc The first function normally called is msgget to either open an existing queue or create a new queue.  \n#include <sys/msg.h>  \nint msgget(key_t key, int flag);  \nReturns: message queue ID if OK, 1 on error  \nWhen a new queue is created, the following members of the msqid_ds  structure are initialized.  \n\uf0fc The ipc_perm structure is initialized. The mode member of this structure is set to the corresponding \npermission bits of  flag.  \n\uf0fc msg_qnum , msg_lspid , msg_lrpid , msg_stime , and msg_rtime  are all set to 0.  \n\uf0fc msg_ctime  is set to the current time.  \n\uf0fc msg_qbytes  is set to the system limit.  \nOn success, msgget returns the non -negative queue ID. This value is then used with the other three \nmessage queue functions.  \nMsgctl \n\uf0fc The msgctl function performs various operations on a queue.  \n#include <sys/msg.h>  \nint msgctl(int msqid, int cmd, struct msqid_ds *buf );  \nReturns: 0 if OK, -1 on error  \nThe cmd argument specifies the command to be performed on the queue specified by msqid.  \n \nMODULE 4  UNIX Programming  \n \n \n11BrCE, Bengaluru  \n Msgsnd \n\uf0fc Data is placed onto a message queue by calling msgsnd . \n#include <sys/msg.h>  \nint msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);  \nReturns: 0 if OK, -1 on error  \n\uf0fc Each message is composed of a positive long integer type field, a non -negative  length (nbytes), and the \nactual data bytes (corresponding to the length). Messages are always placed at the end of the queue.  \n\uf0fc The ptr argument points to a long integer that contains the positive integer message type, and it is \nimmediately followed by the message data. (There is no message data if nbytes is 0.) If the largest message \nwe send is 512 bytes, we can define the following structure:  \nstruct mymesg  \n{ \nlong mtype; /* positive message type  */ \nchar mtext[512]; /* message data, of length nbytes  */ \n}; \n\uf0fc The ptr argument is then a pointer to a mymesg structure. The message type can be used by the receiver to \nfetch messages in an order other than first in, first out.  \n \nmsgrcv   \n\uf0fc Messages are retrieved from a queue by msgrcv  \n#include <sys/msg.h>  \nssize_t msgrcv( int msqid, void *ptr, size_t nbytes, long type, int flag);  \nReturns: size of data portion of message if OK, -1 on error.  \nThe type argument lets us specify which message we want.  \n \ntype == 0  The first message on the queue is returned.  \ntype > 0  The first message on the queue whose message type equals type is returned.  \ntype < 0  The first message on the queue whose message type is the lowest value less \nthan or equal to the absolute value of type is returned.  \n \nSEMAPHORES  \nA semaphore is a counter used to provide access to a shared data object for multiple processes.  \nTo obtain a shared resource, a process needs to do the following:  \n1. Test the semaphore that controls the  resource.  \n2. If the value of the semaphore is positive, the process can use the resource. In this case, the process \nMODULE 4  UNIX Programming  \n \n \n12BrCE, Bengaluru  \n decrements the semaphore value by 1, indicating that it has used one unit of the  resource.  \n3. Otherwise, if the value of the semaphore is 0, the process goe s to sleep until the semaphore value is \ngreater than 0. When the process wakes up, it returns to step  1. \n \nWhen a process is done with a shared resource that is controlled by a semaphore, the semaphore value is \nincremented by 1. If any other processes are a sleep, waiting for the semaphore, they are awakened.  \nA common form of semaphore is called a binary semaphore . It controls a single resource, and its value is \ninitialized to 1. In general, however, a semaphore can be initialized to any positive value, with the value \nindicating how many units of the shared resource are available for  sharing.  \nXSI semaphores are, unfortunately, more complicated than this. Three features contribute to this unnecessary \ncomplication.  \n1. A semaphore is not simply a single non -negative  value. Instead, we have to define a semaphore as a set \nof one or more semaphore values. When we create a semaphore, we specify the number of values in \nthe set. \n2. The creation of a semaphore (semget) is independent of its initialization (semctl). This is a f atal flaw, \nsince we cannot atomically create a new semaphore set and initialize all the values in the  set. \n3. Since all forms of XSI IPC remain in existence even when no process is using them, we have to worry \nabout a program that terminates without releasing  the semaphores it has been allocated. The undo \nfeature that we describe later is supposed to handle  this.  \nThe kernel maintains a semid_ds  structure for each semaphore set:  \nstruct semid_ds  \n   { \n     struct ipc_perm  sem_perm;   \n     unsigned  short sem_nsems ; /* # of semaphores in set */  \n     time_t sem_otime; /* last -semop() time  */ \n     time_t sem_ctime; /* last -change time  */ \n. \n. \n. \n}; \nEach semaphore is represented by an anonymous structure containing at least the following members:  \nstruct \n{ \nunsigned  short semval; /* semaphore value, always >= 0 */  \npid_t sempid; /* pid for last operation  */ \nunsigned  short semncnt;  /* # processes awaiting semval>curval */  \nunsigned  short semzcnt;  /* # processes awaiting \nsemval==0  */ \n. \n. \n. \n}; \n \n \n \nMODULE 4  UNIX Programming  \n \n \n13BrCE, Bengaluru  \n semget  \nThe first function to call is semget to obtain a semaphore ID.  \n#include <sys/sem.h>  \nint semget(key_t key, int nsems, int flag);  \nReturns: semaphore ID if OK, 1 on error  \nWhen a new set is created, the following members of the semid_ds structure are initiali zed. \n\uf0fc The ipc_perm structure is initialized. The mode member of this structure is set to the corresponding \npermission bits of flag.  \n\uf0fc sem_otime is set to 0.  \n\uf0fc sem_ctime is set to the current time.  \n\uf0fc sem_nsems is set to nsems.  \n\uf0fc The number of semaphores in the set is nsems. If a new set is being created (typically in the server), we must \nspecify nsems. If we are referencing an existing set (a client), we can specify nsems as 0.  \n \nSemctl  \n \n\uf0fc The semctl  function is the catchall for various semaphore operations.  \n#include <sys/sem.h>  \nint se mctl(int semid, int semnum, int cmd,... /* union semun arg */);  \n\uf0fc The fourth argument is optional, depending on the command requested, and if present, is of type semun, a  \nunion of various command -specific arguments:  \nunion semun  \n{ \nintval;                                               /* for SETVAL */  \nstruct semid_ds *buf;                       /* for IPC_STAT and IPC_SET */  \nunsigned short  *array;                       /* for GETALL and SETALL */  \n}; \nMODULE 4  UNIX Programming  \n \n \n14BrCE, Bengaluru  \n \uf0fc The cmd argument specifies one of the above ten commands to be performed on the set specified by semid.  \nsemop  \n\uf0fc The function semop atomically performs an array of operations on a semaphore set.  \n#include <sys/sem.h>  \nint semop(int semid, struct sembuf semoparray[  ], size_t nops);  \nReturns: 0 if OK, -1 on error.  \n \n \n\uf0fc The semoparray argument is a pointer to an array of semaphore operations, represented by sembuf \nstructures:  \nstruct sembuf  \n{ \nunsigned short sem_num ; /* member # in set (0, 1, ..., nsems -1) */  \nshort sem_op; /* operation (negative, 0, or positive) */  \nshort sem_flg; /* IPC_NOWAIT, SEM_UNDO  */ \n}; \n\uf0fc The nops argument specifies the number of operations (elements) in the array.  \n\uf0fc The sem_op element operations  are values specifying the amount by which the semaphore value is \nto be changed.  \n\uf0b7 If sem_op is an integer greater than zero , semop adds the value to the corresponding semaphore \nelement value and awakens all processes that are waiting for the element to  increase.  \n\uf0b7 If sem_op is 0 and the semaphore element value is not 0, semop blocks the calling process (waiting for \n0) and increments the count of processes waiting for a zero value of that  element.  \n\uf0b7 If sem_op is a negative number, semop adds the sem_op value to the corresponding semaphore \nelement value provided that the result would not be negative. If the operation would make the element \nvalue negative, semop blocks the process on the event that the semaphore element value increases. If \nMODULE 4  UNIX Programming  \n \n \n15BrCE, Bengaluru  \n the resulting value is  0, semop wakes the processes waiting for  0. \n \n \n \n \n \n \n \n \n"}]}
